[
["index.html", "Reliable Construction of Matrix Population Models from Demographic Information Preface", " Reliable Construction of Matrix Population Models from Demographic Information Bruce E. Kendall 2019-12-04 Preface Matrix population models are powerful tools for quantitatively integrating demographic (births and deaths) and life history (aging, growth and development) information to address ecological questions as well as prioritizing management for rare, harvested, or invasive species. Over the past three decades, the number of animal and plant MPMs described and analyzed in the peer-reviewed literature has grown faster than linearly. This growth can be attributed to two factors. First, more studies are collecting complete demographic information on a population, either as an end in itself or as a side effect of other study objectives (e.g., evolutionary ecology studies that track fitness components throughout the lives of individuals and relatedness among individuals generate great demographic data). Second, MPMs have been promoted (primarily by modellers) as an “easy” way to integrate demographic demographic information and draw novel conclusions from them. Initially, most “empirical MPMs” (models of actual populations, as opposed to theoretical constructs) were created by collaborations between field biologists (who provided the data) and modellers (who took care of the mathematical details). Subsequently, MPMs came to be viewed as DIY (do it yourself) models that any trained ecologist or conservation biologist could do, and many MPMs are now published without the assistance of an expert modeller. It is true that the conceptual mapping of demographic and life history information to a projection matrix is (usually) straightforward. But there are bookkeeping details (that affect the quantititative mapping) that are not biologically intuitive, and may be actively counter-intuitive. When following the textbook approaches to MPM construction, getting these bookkeeping details just right can be tricky if one is not used to “thinking like a modeller.” Now, I am an ecological modeller, and as such I find the details of MPM bookkeeping intuitive.1 But I also have lots of experience in teaching MPMs to students who are new to modelling, and have noticed the places where they repeatedly have trouble accepting the need for, or even the validity of, the bookkeeping details. When building their own models in class exercises, they often make mistakes in these places. Furthermore, one of the class assignments is to work with a published MPM of the student’s choice. One year, every one of the models selected by the students had mistakes!2 This inspired me to take a more systematic look at published MPMs. Among animal MPMs, I found that between 35% and 60% (depending on the type of error) of published models were incorrectly formulated; and that the error rate was constant through time.3 This led me to wonder if there was a more effective way to teach non-modellers how to construct MPMs. The audience for this book is ecologists and conservation biologists whose focus is primarily empirical: you are used to collecting data and analyzing it using statistical models, but you are not well-versed in constructing and analyzing mathematical models. In this book I introduce a new approach to MPM construction that keeps you, the biolgist, focused on events in the life cycle of your organism, and uses the computer to integrate all the pieces into the model. I am also striving for a presentation that is accessible (in the sense of putting biological concepts ahead of mathematical convenience), consistent in presentation across different types of models, and a comprehensive treatment of the range of life histories that can be represented with MPMs. I start with the classic age-, size-, and stage-structured MPMs, assuming that the within-year life-history is fairly straightforward. I then show how the general approach can be expanded to incorporate richer biological detail into the model, such as extended pregnancy or periods when the offspring is dependent on its parents for survival. Basically, intuition in any subject is arrived at through repetition; I’ve built lots of models over the years!↩ Not only does this highlight the difficulty in correctly constructing MPMs, it says something disturbing about peer review….↩ These results were published in Kendall et al. (2019) Ecological Modelling 406: 33–43.↩ "],
["intro.html", "Chapter 1 Introduction 1.1 What are matrix population models? 1.2 What are matrix population models used for? 1.3 A brief history of matrix population models 1.4 Common pitfalls in matrix population model construction 1.5 Mathematical essentials 1.6 Matrix population models in R", " Chapter 1 Introduction 1.1 What are matrix population models? The population models that are taught in undergraduate ecology courses—the exponential growth model, logistic model, Ricker model, etc.—are useful for explaining and illustrating basic patterns in population dynamics, such as patterns of exponential growth, the effects of density dependence, and phenomena such as population cycles and chaos. Their utility stems from their simplicity, which allows them to be analyzed without recourse to pages of advanced math. In particular, most of these foundational models assume that all individuals in the population can be treated as if they have identical birth and death rates. As a practicing ecologist or conservation biologist, you know first-hand that all individuals in a population are not identical: they age, develop, and grow; and birth and death rates (which I will collectiely call “demography”) often vary systematically with age, developmental stage, and size. Individuals can differ in other important ways as well: for example, individuals of a given age may exhibit morphological variation resulting from genetic differences or heterogeneity in their developmental environment; or they might exhibit different behavioral responses to a given stimulus resulting from variation in prior experience. These phenotypic differences can also affect demography. Ultimately, an individual’s short-term fitness (its survival probability or mortality risk, as well as its expected birth rate) depends on both its state (age, stage, or size), its phenotype, and the environment (encompassing abiotic conditions and resources as well other organisms with which it interacts) in which it lives. Simple models that characterize the population simply by its abundance, density, or biomass cannot represent this biological richness; thus, they do no provide insight on whether this richness matters for population dynamics, or how it might be exploited to manage the population (e.g., to arrest the decline of a rare species). On the other hand, a model that encompassed all of this, together with all of the feedback loops between the focal species and the ecological community it’s embedded in, would be tremendously complex (browse any issue of the journal Ecological Modelling to see examples) and would require tremendous amounts of data to estimate all the parameters. MPMs are intermediate complexity Assumptions: discrete state and discrete time; also linearity for standard model “M” comes from use of matrix algebra to both make representation more compact and to give access to analytical and computational tools The standard models only require information on survival fraction and mean birth rates across individuals within each class, as well as information on the probability that an individual moves from one class to another. 1.2 What are matrix population models used for? 1.3 A brief history of matrix population models 1.4 Common pitfalls in matrix population model construction Summary of ideas and results in Kendall et al. (2019). 1.5 Mathematical essentials 1.5.1 Notation There is no getting around the fact that MPMs are mathematical constructs. However, I will try to make the notation be as closely tied to the biology as possible. One challenge is that we nned a consistent way to reference demographic rates of specific age, size, or stage classes. In mathematical notation, \\(p_i\\) is the survival rate of individuals in the \\(i\\)’th class. Thus, for example, in an age-structured model with age classes 0, 1, 2, and so on, \\(p_2\\) is the survival of one-year-olds. In a stage-structured model with stage classes newborn, juvenile, sub-adult and adult, then \\(p_2\\) is the survival of juveniles. Keeping track of this mapping requires extra cognitive work, and can be especially confusing in age-structured models where the mathematical index and the biological age don’t align.4 Thus I introduce a biological notation, in which the actual age or the name of the class is shown between parentheses in the subscript. Thus, in an age-structured model, \\(p_{(2)}\\) is the survival of two-year-olds (survival from age 2 to age 3). In a stage-structured model, \\(p_{(\\text{sub-adult})}\\) is the annual survival of individuals who start the year in the sub-adult stage. This distinction is also useful in referencing the vector of population abundances in year \\(t\\), \\(\\mathbf{n}(t)\\). As we will see, MPMs can be constructed in different ways that either do or do not include newborn individuals in the population vector. In that case, careful attention to context is required to know what \\(n_1(t)\\) (the first element of \\(\\mathbf{n}(t)\\)) refers to. In contrast, \\(n_{(0)}(t)\\) vs. \\(n_{(1)}(t)\\), or \\(n_{(\\text{newborn})}(t)\\) vs. \\(n_{(\\text{juvenile})}(t)\\), is clear and unambiguous. Transition notation 1.5.2 Matrix multiplication 1.6 Matrix population models in R References "],
["general-considerations.html", "Chapter 2 General Considerations", " Chapter 2 General Considerations "],
["age-structured-models.html", "Chapter 3 Age-Structured Models 3.1 The recipe 3.2 Example 3.3 Why use this recipe? 3.4 Extensions, caveats, and assumptions", " Chapter 3 Age-Structured Models 3.1 The recipe 3.1.1 Ingredients For more details on data needs, see XXX, but in brief: A list of annual survival rates (the fraction of individuals that survive for a year), one for each age. Ideally, this will be survival from one birthay to the next (including from birth to the first birthday). If males and females have different survival rates, list the female values. We will call this list the vector \\(\\mathbf{p}\\), with elements \\(p_{(\\text{0})}\\) (survival probability from birth to age 1), \\(p_{(\\text{1})}\\) (survival probability from age 1 to age 2), \\(p_{(\\text{2})}\\) (survival probability from age 2 to age 3), etc. A list of age-specific birth rates: For each parental age, the number of offspring per parent (counting both parents), or the number of female offspring produced by each female parent. We will call this list the vector \\(\\mathbf{b}\\), with elements \\(b_{(\\text{1})}\\) (newborns produced by a 1-year-old parent), \\(b_{(\\text{2})}\\) (newborns produced by a 2-year-old parent), etc. Newborns cannot reproduce, so there is no value of \\(b_{(\\text{0})}\\); if the age at first reproduction is less than one, then you will need a shorter timestep. Identify the maximum age, above which there is no survival. Call this age \\(m\\); while there may be a non-zero birth rate \\(b_{(\\text{m})}\\), \\(m\\)-year-olds do not survive to age \\(m+1\\), so \\(p_{(\\text{m})} = 0\\). When these are arranged in tabular form, it will look like part of a life table, which you may recall from undergraduate ecology courses. In fact, these two lists provide all the information needed to construct the other columns of the life table (such as the cumulative survivorship, \\(l_x\\)); but we don’t need those to construct an MPM, so don’t pursue that further. Figure 3.1: The viviparous lizard (Zootoca vivipara) in the Aamsveen, The Netherlands. CC-BY-SA Ocrdu. The example we will use in this chapter comes from Strijbosch and Creemers (1988), who quantified the age-specific demography of the viviparous lizard (Zootoca vivipara; Fig. 3.1) in an intensive 7-year study on a 1.2 ha plot at the forest reserve “de Hamert” in the Netherlands. The age-specific female birth and survival rates are shown in Table 3.1. Table 3.1: Age-specific survival and birth rates for the lizard Zootoca vivipara (formerly Lacerta vivipara) in the Netherlands (Strijbosch and Creemers 1988). Age-specific annual survival is calculated from the female cumulative survival values (\\(l_x\\)) in their Table 6. Age-specific birth rates are calculated by dividing the birth rates in their Table 6 (\\(m_x\\)) by two, as these appear to represent all offspring, and the primary sex ratio (estimated from two-year-old individuals) did not differ from 1 (pp. 21-22). Age in years (\\(x\\)) Female annual survival (\\(p_{(\\text{x})}\\)) Female offpring per female (\\(b_{(\\text{x})}\\)) 0 0.424 NA 1 0.726 0.040 2 0.513 1.470 3 0.361 2.065 4 0.175 2.440 5 0.700 3.250 6 0.286 3.250 7 0.000 3.250 3.1.2 Construct the birth matrix, \\(\\mathbf{B}\\) Make an \\(m \\times m\\) identity matrix (with ones on the diagonal, and zeros everywhere else) Add an extra row on top, with the birth rates If \\(m=3\\), this would look like: \\[\\begin{equation} \\mathbf{B} = \\begin{pmatrix} b_{(\\text{1})} &amp; b_{(\\text{2})} &amp; b_{(\\text{3})} \\\\ 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{pmatrix} \\tag{3.1} \\end{equation}\\] 3.1.3 Construct the survival matrix, \\(\\mathbf{P}\\) Make an \\(m \\times m\\) matrix with the survival values on the diagonal, and zeros everywhere else Add an extra column of zeros on the right If \\(m=3\\), this would look like: \\[\\begin{equation} \\mathbf{P} = \\begin{pmatrix} p_{(\\text{0})} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; p_{(\\text{1})} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; p_{(\\text{2})} &amp; 0 \\end{pmatrix} \\end{equation}\\] 3.1.4 Combine the birth and survival matrices into the projection matrix You have two choices here: the postbreeding census model (which we denote \\(\\mathbf{A_{post}}\\)), which takes the population immediately after the breeding season in one yeqr (including the newborns) and projects it to immediately after the breeding season the next year; the prebreeding census model (which we denote \\(\\mathbf{A_{pre}}\\)), which takes the population immediately before the breeding season in one yeqr (so that the youngest individuals are just about to reach their first birthday) and projects it to immediately before the breeding season the next year. Both versions model the same population; the only difference is when you peek in to see the population abundances. Here are the formulas: \\[\\begin{equation} \\begin{aligned} \\mathbf{A_{post}} &amp;= \\mathbf{B} \\mathbf{P}\\\\ \\mathbf{A_{pre}} &amp;= \\mathbf{P} \\mathbf{B} \\end{aligned} \\end{equation}\\] The formulas look similar, differing only in the order of multiplication. But remember that matrix multiplication is not commutative! For the \\(m=3\\) case above, these work out to: \\[\\begin{equation} \\begin{aligned} \\mathbf{A_{post}} &amp;= \\begin{pmatrix} p_{(\\text{0})} b_{(\\text{1})} &amp; p_{(\\text{1})} b_{(\\text{2})} &amp; p_{(\\text{2})} b_{(\\text{3})} &amp; 0\\\\ p_{(\\text{0})} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; p_{(\\text{1})} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; p_{(\\text{2})} &amp; 0 \\end{pmatrix} \\\\ \\mathbf{A_{pre}} &amp;= \\begin{pmatrix} b_{(\\text{1})} p_{(\\text{0})} &amp; b_{(\\text{2})} p_{(\\text{0})} &amp; b_{(\\text{3})} p_{(\\text{0})} \\\\ p_{(\\text{1})} &amp; 0 &amp; 0 \\\\ 0 &amp; p_{(\\text{2})} &amp; 0 \\end{pmatrix} \\end{aligned} \\tag{3.2} \\end{equation}\\] 3.2 Example Let’s apply this to the lizard life table in Table 3.1. This model is large enough that I don’t want to calculate it by hand, so I’ll use R. First, enter the age-specific survival and birth rates, and the maximum age: px &lt;- c(0.424, 0.726, 0.513, 0.361, 0.175, 0.700, 0.286) # Survival bx &lt;- c(0.040, 1.470, 2.065, 2.440, 3.250, 3.250, 3.250) # Births m &lt;- 7 # Maximum age Notice that the first element of px is \\(p_{(\\text{0})}\\), whereas the first element of bx is \\(b_{(\\text{1})}\\). Thus, px doesn’t have the zero surivival of 7-year-olds, and bx doesn’t have the zero birth rate of newborns. If you are working with a dataset that includes these zeros, you’ll need to trim them off before moving to the next step. Now construct the birth matrix, \\(\\mathbf{B}\\). A useful function in R is diag(), the diagonal function. If m is a scalar (a single number), then diag(m) creates an \\(m \\times m\\) matrix with ones on the diagonal and zeros everywhere else. Also, recall that rbind() (“row bind”) adds the second argument below the first argument. B &lt;- diag(m) # Make an m x m diagonal matrix B &lt;- rbind(bx, B) # Add an extra row on top, with the birth rates B ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## bx 0.04 1.47 2.065 2.44 3.25 3.25 3.25 ## 1.00 0.00 0.000 0.00 0.00 0.00 0.00 ## 0.00 1.00 0.000 0.00 0.00 0.00 0.00 ## 0.00 0.00 1.000 0.00 0.00 0.00 0.00 ## 0.00 0.00 0.000 1.00 0.00 0.00 0.00 ## 0.00 0.00 0.000 0.00 1.00 0.00 0.00 ## 0.00 0.00 0.000 0.00 0.00 1.00 0.00 ## 0.00 0.00 0.000 0.00 0.00 0.00 1.00 ALthough it’s larger, this matrix has the same structure as Eq. ((3.1)). One quirk of R is that, while the columns are labeled with the index of the columns (which is what we expect for a generic matrix), the first row is labeled “bx” and the rest of the rows are unlabeled. The labels don’t actually matter for the rest of the calculations, but they will result in the final matrices having uninformative row labels. If you don’t like this, you can reset the row labels with the command rownames(B) &lt;- NULL. Alternatively, you can use this slightly more complex command (it also does both steps at once): B &lt;- matrix(c(bx, diag(m)), nrow = m + 1, ncol = m, byrow = TRUE) B ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## [1,] 0.04 1.47 2.065 2.44 3.25 3.25 3.25 ## [2,] 1.00 0.00 0.000 0.00 0.00 0.00 0.00 ## [3,] 0.00 1.00 0.000 0.00 0.00 0.00 0.00 ## [4,] 0.00 0.00 1.000 0.00 0.00 0.00 0.00 ## [5,] 0.00 0.00 0.000 1.00 0.00 0.00 0.00 ## [6,] 0.00 0.00 0.000 0.00 1.00 0.00 0.00 ## [7,] 0.00 0.00 0.000 0.00 0.00 1.00 0.00 ## [8,] 0.00 0.00 0.000 0.00 0.00 0.00 1.00 Even better, give the matrix informative row and column names. The columns represent the parents, so we would want to label the columns “age 1”, “age 2”, etc. The first row represents the newborns (age zero), and the rest of the rows are still the parents (who haven’t aged, as we are assuming that the breeding season is very short), so we want to label the rows “age 0”, “age 1”, “age 2”, etc. We set the column and row names using the R functions colnames() and rownames(), respectively. The other trick is to use the paste() command to generate an appropriate character vector: for example, paste(&quot;age&quot;, 1:3) generates the character vector &quot;age 1&quot;, &quot;age 2&quot;, &quot;age 3&quot;. colnames(B) &lt;- paste(&quot;age&quot;, 1:m) rownames(B) &lt;- paste(&quot;age&quot;, 0:m) B ## age 1 age 2 age 3 age 4 age 5 age 6 age 7 ## age 0 0.04 1.47 2.065 2.44 3.25 3.25 3.25 ## age 1 1.00 0.00 0.000 0.00 0.00 0.00 0.00 ## age 2 0.00 1.00 0.000 0.00 0.00 0.00 0.00 ## age 3 0.00 0.00 1.000 0.00 0.00 0.00 0.00 ## age 4 0.00 0.00 0.000 1.00 0.00 0.00 0.00 ## age 5 0.00 0.00 0.000 0.00 1.00 0.00 0.00 ## age 6 0.00 0.00 0.000 0.00 0.00 1.00 0.00 ## age 7 0.00 0.00 0.000 0.00 0.00 0.00 1.00 Now construct the survival matrix, \\(\\mathbf{P}\\). We will again use diag(), but in a different way. If px is a vector with length \\(m\\), then diag(px) creates an \\(m \\times m\\) matrix with the values of px on the diagonal and zeros everywhere else. Also, recall that cbind() (“column bind”) adds the second argument to the right the first argument. P &lt;- diag(px) # Make the diagonal matrix with survival values P &lt;- cbind(P, 0) # Add an extra column of zeros P ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 0.424 0.000 0.000 0.000 0.000 0.0 0.000 0 ## [2,] 0.000 0.726 0.000 0.000 0.000 0.0 0.000 0 ## [3,] 0.000 0.000 0.513 0.000 0.000 0.0 0.000 0 ## [4,] 0.000 0.000 0.000 0.361 0.000 0.0 0.000 0 ## [5,] 0.000 0.000 0.000 0.000 0.175 0.0 0.000 0 ## [6,] 0.000 0.000 0.000 0.000 0.000 0.7 0.000 0 ## [7,] 0.000 0.000 0.000 0.000 0.000 0.0 0.286 0 Again, we add row and column names. Here, the columns represent the ages right at the end of the breeding season (ages 0 through \\(m\\)), whereas the rows represents the ages at the beginning of the next breeding season a year later (ages 1 through \\(m\\)): colnames(P) &lt;- paste(&quot;age&quot;, 0:m) rownames(P) &lt;- paste(&quot;age&quot;, 1:m) P ## age 0 age 1 age 2 age 3 age 4 age 5 age 6 age 7 ## age 1 0.424 0.000 0.000 0.000 0.000 0.0 0.000 0 ## age 2 0.000 0.726 0.000 0.000 0.000 0.0 0.000 0 ## age 3 0.000 0.000 0.513 0.000 0.000 0.0 0.000 0 ## age 4 0.000 0.000 0.000 0.361 0.000 0.0 0.000 0 ## age 5 0.000 0.000 0.000 0.000 0.175 0.0 0.000 0 ## age 6 0.000 0.000 0.000 0.000 0.000 0.7 0.000 0 ## age 7 0.000 0.000 0.000 0.000 0.000 0.0 0.286 0 Finally, we use matrix multiplication to get the projection matrices. In R, matrix multiplication is indicated with the compound symbol %*% (if you just used * then it would do element-by-element multiplication, which is mathematically very different). # Make the postbreeding census model Apost &lt;- B %*% P Apost ## age 0 age 1 age 2 age 3 age 4 age 5 age 6 age 7 ## age 0 0.01696 1.06722 1.059345 0.88084 0.56875 2.275 0.9295 0 ## age 1 0.42400 0.00000 0.000000 0.00000 0.00000 0.000 0.0000 0 ## age 2 0.00000 0.72600 0.000000 0.00000 0.00000 0.000 0.0000 0 ## age 3 0.00000 0.00000 0.513000 0.00000 0.00000 0.000 0.0000 0 ## age 4 0.00000 0.00000 0.000000 0.36100 0.00000 0.000 0.0000 0 ## age 5 0.00000 0.00000 0.000000 0.00000 0.17500 0.000 0.0000 0 ## age 6 0.00000 0.00000 0.000000 0.00000 0.00000 0.700 0.0000 0 ## age 7 0.00000 0.00000 0.000000 0.00000 0.00000 0.000 0.2860 0 # Make the prebreeding census model Apre &lt;- P %*% B Apre ## age 1 age 2 age 3 age 4 age 5 age 6 age 7 ## age 1 0.01696 0.62328 0.87556 1.03456 1.378 1.378 1.378 ## age 2 0.72600 0.00000 0.00000 0.00000 0.000 0.000 0.000 ## age 3 0.00000 0.51300 0.00000 0.00000 0.000 0.000 0.000 ## age 4 0.00000 0.00000 0.36100 0.00000 0.000 0.000 0.000 ## age 5 0.00000 0.00000 0.00000 0.17500 0.000 0.000 0.000 ## age 6 0.00000 0.00000 0.00000 0.00000 0.700 0.000 0.000 ## age 7 0.00000 0.00000 0.00000 0.00000 0.000 0.286 0.000 Notice that the row and column names that we set for the B and P matrices propagated through automatically, so that the first row and column of the postbreeding model represents newborns (“age 0”), whereas in the prebreeding census model the irst row and column represents age 1 (the youngest individuals are just about to have their first birthday). If you work through the numbers, you’ll see that these match the structure of the post-breeding and pre-breeding matrices in Eq. (3.2). In theory, these two matrices should have exactly the same asymptotic growth rate, \\(\\lambda\\). Lets use the lambda() function in the popbio package to check this: library(popbio) lambda(Apost) ## [1] 0.9986679 lambda(Apre) ## [1] 0.9986679 Yup, they match! We will want to use this model later in the book, so package it up into a list for easy access: lizard_age_mpm &lt;- list( Apost = Apost, Apre = Apre, B = B, P = P, px = px, bx = bx, m = m ) 3.3 Why use this recipe? Now, these matrices don’t look that complex; why didn’t I tell you how to construct them directly, rather than constructing the intermediate birth and survival matrices? Look at the matrix elements on the top row of each matrix; these are called the fertility coefficients, and represent the reproducive component of the model. Look at how they are constructed from survival and birth rates: does this make sense to you? If it does not, don’t worry: it is not an implementation of biological intuition, but instead a bunch of bookkeeping. But first I would need to convince you that these are the right formulas; and then I would need to look over your shoulder and remind you to use them each time you constructed a model, because, like double-entry bookkeeping, it is easy to forget what to do unless you do it often. 3.4 Extensions, caveats, and assumptions 3.4.1 No maximum age The recipe and example above describes a classic Leslie matrix model, in which there is a well-defined maximum age at which all individuals die. In many species, however, individuals may survive more-or-less indefinitely; above a certain age, it might be biologically reasonable to assume that all indiviudals have the same birth and survival rates, independent of age. Even if there is not strong evidence to support that assumption, there may be so few old individuals in the population that it is impossible to estimate separate demographic rates for each age class. In this case, we can augment the Leslie model by adding an “old individual” stage; while this technically becomes a stage-structured model, it is such a common modification to age structured models that we include it here. Now, instead of \\(m\\) being the maximum age, we can write \\(m+\\) to represent the class of individuals age \\(m\\) and above. They have a non-zero survival, so the vector of survival values now has \\(m+1\\) values (\\(p_{(\\text{0})}, p_{(\\text{1})}, \\dots, p_{(\\text{m-1})}, p_{(\\text{m+})}\\)). The only modification to the recipe above is to put the value of \\(p_{(\\text{m+})}\\) into the bottom-right element of the \\(\\mathbf{P}\\) matrix. All else proceeds as above. 3.4.2 Post-reproductive ages In many animal species, individuals may survive beyond their maximum age of reproduction. These post-reproductive age classes have birth rates of zero, and the resulting projection matrix may be problematic for certain sorts of analyses. There is no problem with using the matrix to numerically simulate the age-structured population through time. However, analyses that require calculating the eigenvalues and eigenvectors of the matrix, such as the asymptotic population growth rate, \\(\\lambda\\), and the sensitivity of \\(\\lambda\\) to matrix elements, might generate mysterious errors (depending on the software being used). If this occurs, you can simply delete the rows and columns of the projection matrix that are associated with the post-reproductive ages, and re-do the analysis. Because population growth is unaffected (at least in simple density-independent models such as these) by the survival of post-reproductive ages, you can set those sensitivity values to zero after analyzing the remainder of the matrix. 3.4.3 Extended breeding season In describing the recipe above, I have made some potentially troubling assumptions. To be clear, these assumptions are embedded in the “standard” approach to constructing MPMs; the use of seasonal matrices merely makes them more apparent. The first such assumption is that the breeding season is “instantaneous,” such that there is no mortality during the season and all individuals in a cohort are exactly the same age. This is the standard assumption in the “birth-pulse” models that we are describing here. If reproduction occurs continuously throughout the year, without seasonal variation, then there is a “birth-flow” formalism that approximates this. I don’t treat that here, as truly aseasonal reproduction is vanishingly rare in the wild, and in the literature I have only seen birth-flow models applied to human and laboratory populations. However, it would be possible to extend the breeding season component of the model to extend to a finite duration, during which both parents and offspring might die, and in which first-year survival of offspring might depend on when in the breeding season they were born. I will explore this in a subsequent chapter. 3.4.4 Dependent offspring Another potentially important feature of many animals’ life history is an extended period when offpring are dependent on their parents for food and protection. In such a situation, the death of the parent may lead to reduced (or zero) survival for the offspring. The standard age-structured MPM, as we have developed above, does not account for this. If the dependence lasts for a full year (or more), this can be addressed by creating a special class for “mothers with offspring,” as was done by Fujiwara and Caswell (2001) in their model for the North Atlantic right whale. For shorter perdiods of parental care, we could create a post-birth “dependency season” during which the fates of parents and offspring are correlated. A related issue arises with extended gestation periods, creating a pre-birth dependency season. Furthermore, if pregnancy affects maternal survival, we could explicitly distinguish pregnant and non-pregnant females during that season, allowing the model to incorporate tradeoffs between survival and reproduction. I will address these issues in a subsequent chapter. 3.4.5 Individual heterogeneity Finally, the model assumes that all individuals of a given age have the same birth and death rates. Violation of this assumption creates “unmodelled heterogeneity,” and might affect the predictions of your model, depending on the nature of the heterogeneity and the way you are using the model. Both the identification of such heterogeneity and the consequences are ongoing areas of research; I won’t provide a general treatment in this book, but will touch on it in certain points where it commonly arises. References "],
["stage-structured-models.html", "Chapter 4 Stage-Structured Models 4.1 The recipe 4.2 Example", " Chapter 4 Stage-Structured Models We now turn to models of populations in which developmental stage is a stronger determinant of demography than is age or size. In the classical formulation, known as Lefkovitch matrices, an individual, if it survives, may either stay in its current stage or move to the next stage. This creates a characteristic matrix shape in which the non-zero values comprise fertility coefficients across the top row, diagonal elements representing surviving and staying in the next stage, and sub-diagonal elements representing survival and maturation to the next stage (Fig. XXX). To construct such models, we need to know how demography depends on stage: for each stage \\(i\\), what is the birth rate (\\(b_i\\)) and survival rate (\\(p_i\\))? In addition, we need to know, of the individuals starting in stage \\(i\\) that survive for a year, what fraction mature to stage \\(i+1\\) by the end of the year? We will call this value \\(g_i\\), and name it the “maturation rate” (many texts and articles call this “growth,” but I reserve that term for talking about increases in size). Estimating the maturation rates properly is a somewhat subtle process, depending both on the biology of how individuals move through the developmental stages and on how the model will be used. We will look at that in a later section of this chapter. First, however, we will look at how to construct a matrix once you have all these values. 4.1 The recipe The stage-tructured model uses the same sort of birth and survival matrices (\\(\\mathbf{B}\\) and \\(\\mathbf{P}\\)) as the age-structured model, so I encourage you to read Chapter 3 before proceeding here. In addition, the construction of some of the elements will differ slightly depending on whether the newborn life stage has the potential to persist in that stage (e.g., in many plants a seed that doesn’t germinate may remain a viable seed) or must mature to the next stage (as in most animals). 4.1.1 Ingredients The name of the newborn stage (e.g., neonate, egg, seed) and a list of the \\(l\\) subsequent developmental stages to include in the model. This may be a subset of the actual developmental stages, if the species passes through multiple stages in a timestep (which is set by the breeding interval, and is typically one year). For example, if a newborn fish starts as an egg and passes through the stages larva, swimming juvenile, settled juvenile in its first year, the first two stages in the model would be egg and settled juvenile, and the the survival and maturation rates would relate to survival from egg all the way to settled juvenile. We will index the stages with \\(i\\). A list of annual survival rates (the fraction of individuals that survive for a year), one for each stage. Ideally, this will be survival from one birthay to the next (including from birth to the first birthday). If males and females have different survival rates, list the female values. We will call this list the vector \\(\\mathbf{p}\\), with elements \\(p_i\\) being the annual survival rate (fraction of individuals surviving, regardles of which stage they end up in) of individuals that start in stage \\(i\\). A list of stage-specific birth rates: For each parental stage, the number of offspring per parent (counting both parents), or the number of female offspring produced by each female parent. We will call this list the vector \\(\\mathbf{b}\\), with elements \\(b_i\\) being the number of offspring produced by a parent in stage \\(i\\). Newborns cannot reproduce, so there is no value of \\(b_0\\). A list of maturation rates (the fraction of surviving individuals in a stage that mature to the next stage), one for each stage. We will call this list the vector \\(\\mathbf{g}\\), with elements \\(g_i\\) being the the fraction of surviving individuals in stage \\(i\\) maturing to stage \\(i+1\\). The remaining fraction (\\(1-g_i\\)) stays in stage \\(i\\). The maturation rate is conditioned on survival, so the fraction of individuals in stage \\(i\\) in one year that are alive and in stage \\(i+1\\) the next year would be \\(p_i g_i\\). Notice that the final stage has nowhere to mature to, so \\(g_l = 0\\). 4.1.2 Construct the birth matrix, \\(\\mathbf{B}\\) 4.1.2.1 Non-persistent newborn stage If all newborns mature to the next developmental stage by their first birthday, then this is identical to the recipe for age-structured models: Make an \\(l \\times l\\) identity matrix (with ones on the diagonal, and zeros everywhere else) Add an extra row on top, with the birth rates If \\(l=3\\), this would look like: \\[\\begin{equation} \\mathbf{B} = \\begin{pmatrix} b_1 &amp; b_2 &amp; b_3 \\\\ 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{pmatrix} \\tag{4.1} \\end{equation}\\] 4.1.2.2 Persistent newborn stage If same newborns may remain in the same stage by their first birthday (e.g., seeds with a seed bank), then the recipe is slightly different: Make an \\((l+1) \\times (l+1)\\) identity matrix (with ones on the diagonal, and zeros everywhere else) Replace the zeros on the top row with the birth rates If \\(l=3\\), this would look like: \\[\\begin{equation} \\mathbf{B} = \\begin{pmatrix} 1 &amp; b_1 &amp; b_2 &amp; b_3 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} \\tag{4.2} \\end{equation}\\] 4.1.3 Construct the survival matrix, \\(\\mathbf{P}\\) The recipe is the same for both persistent and non-persistent newborn stages. It is slightly different (and simpler) than the age-structured case: Make an \\((l+1) \\times (l+1)\\) matrix with the survival values on the diagonal, and zeros everywhere else If \\(l=3\\), this would look like: \\[\\begin{equation} \\mathbf{P} = \\begin{pmatrix} p_0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; p_1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; p_2 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; p_3 \\end{pmatrix} \\end{equation}\\] 4.1.4 Construct the developmental transition matrix, \\(\\mathbf{T}\\) Make an \\((l+1) \\times (l+1)\\) matrix with the matureation rates subtracted from one on the diagonal, and zeros everywhere else Add the first \\(l\\) maturation rates (\\(g_0\\) through \\(g_{l-1}\\)) just below the diagonal If \\(l=3\\), this would look like: \\[\\begin{equation} \\mathbf{T} = \\begin{pmatrix} 1-g_0 &amp; 0 &amp; 0 &amp; 0 \\\\ g_0 &amp; 1-g_1 &amp; 0 &amp; 0 \\\\ 0 &amp; g_1 &amp; 1-g_2 &amp; 0 \\\\ 0 &amp; 0 &amp; g_2 &amp; 1-g_3 \\end{pmatrix} \\end{equation}\\] 4.1.4.1 Non-persistent newborn stage If all newborns mature to the next developmental stage by their first birthday, so that \\(g_0 = 1\\) and the first row of \\(\\mathbf{T}\\) consists only of zeros, then Drop the top row. 4.1.5 Combine the birth, survival, and transition matrices into the projection matrix You have two choices here: the postbreeding census model (which we denote \\(\\mathbf{A_{post}}\\)), which takes the population immediately after the breeding season in one yeqr (including the newborns) and projects it to immediately after the breeding season the next year; the prebreeding census model (which we denote \\(\\mathbf{A_{pre}}\\)), which takes the population immediately before the breeding season in one yeqr (so that the youngest individuals are just about to reach their first birthday) and projects it to immediately before the breeding season the next year. Both versions model the same population; the only difference is when you peek in to see the population abundances. Here are the formulas: \\[\\begin{equation} \\begin{aligned} \\mathbf{A_{post}} &amp;= \\mathbf{B} \\mathbf{T} \\mathbf{P}\\\\ \\mathbf{A_{pre}} &amp;= \\mathbf{T} \\mathbf{P} \\mathbf{B} \\end{aligned} \\end{equation}\\] The formulas look similar, differing only in the order of multiplication. But remember that matrix multiplication is not commutative! However, the term \\(\\mathbf{TP}\\) appears in both, and can be pre-calculated. For the \\(l=3\\) case and a non-persistent newborn stage, these work out to: \\[\\begin{equation} \\mathbf{TP} = \\begin{pmatrix} p_0 &amp; p_1(1-g_1) &amp; 0 &amp; 0 \\\\ 0 &amp; p_1 g_1 &amp; p_2 (1-g_2) &amp; 0 \\\\ 0 &amp; 0 &amp; p_2 g_2 &amp; p_3 \\end{pmatrix} \\end{equation}\\] \\[\\begin{equation} \\begin{aligned} \\mathbf{A_{post}} &amp;= \\begin{pmatrix} p_0 b_1 &amp; p_1 (1-g_1) b_1 + p_1 g_1 b_2 &amp; p_2 (1-g_2) b_2 + p_2 g_2 b_3 &amp; p_3 b_3\\\\ p_0 &amp; p_1 (1-g_1) &amp; 0 &amp; 0 \\\\ 0 &amp; p_1 g_1 &amp; p_2 (1-g_2) &amp; 0 \\\\ 0 &amp; 0 &amp; p_2 g_2 &amp; p_3 \\end{pmatrix} \\\\ \\mathbf{A_{pre}} &amp;= \\begin{pmatrix} b_1 p_0 + p_1(1-g_1) &amp; b_2 p_0 &amp; b_3 p_0 \\\\ p_1 g_1 &amp; p_2 (1-g_2) &amp; 0 \\\\ 0 &amp; p_2 g_2 &amp; p_3 \\end{pmatrix} \\end{aligned} \\tag{4.3} \\end{equation}\\] For the persistent newborn stage these are: \\[\\begin{equation} \\mathbf{TP} = \\begin{pmatrix} p_0 (1-g_0) &amp; 0 &amp; 0 &amp; 0 \\\\ p_0 g_0 &amp; p_1(1-g_1) &amp; 0 &amp; 0 \\\\ 0 &amp; p_1 g_1 &amp; p_2 (1-g_2) &amp; 0 \\\\ 0 &amp; 0 &amp; p_2 g_2 &amp; p_3 \\end{pmatrix} \\end{equation}\\] \\[\\begin{equation} \\mathbf{A_{post}} = \\begin{pmatrix} p_0 (1-g_0) + p_0 g_0 b_1 &amp; p_1 (1-g_1) b_1 + p_1 g_1 b_2 &amp; p_2 (1-g_2) b_2 + p_2 g_2 b_3 &amp; p_3 b_3\\\\ p_0 g_0 &amp; p_1 (1-g_1) &amp; 0 &amp; 0 \\\\ 0 &amp; p_1 g_1 &amp; p_2 (1-g_2) &amp; 0 \\\\ 0 &amp; 0 &amp; p_2 g_2 &amp; p_3 \\end{pmatrix} \\\\ \\tag{4.4} \\end{equation}\\] \\[\\begin{equation} \\mathbf{A_{pre}} = \\begin{pmatrix} p_0 (1-g_0) &amp; b_1 p_0 (1-g_0) &amp; b_2 p_0 (1-g_0) &amp; b_3 p_0 (1-g_0) \\\\ p_0 g_0 &amp; b_1 p_0 g_0 + p_1(1-g_1) &amp; b_2 p_0 g_0 &amp; b_3 p_0 g_0 \\\\ 0 &amp; p_1 g_1 &amp; p_2 (1-g_2) &amp; 0 \\\\ 0 &amp; 0 &amp; p_2 g_2 &amp; p_3 \\end{pmatrix} \\tag{4.5} \\end{equation}\\] The bookkeeping embodied in the the elements of \\(\\mathbf{A_{pre}}\\) and \\(\\mathbf{A_{post}}\\) is getting truly heroic. This will become even worse if transitions are not limited simply to the current stage and the subsequent stage. A standard textbook would urge you to calaculate these elements directly, being very careful to keep track of all the pathways and the steps along each pathway. This path leads to madness. Even expert modelers, for whom the components of the projection matrix elements seem “intuitive,” can lose track and put parameter values in the wrong place. It is far simpler, conceptually and operationally, to plug values into \\(\\mathbf{B}\\), \\(\\mathbf{P}\\), and \\(\\mathbf{T}\\), and do matrix multiplication on the numeric matrices. Or even better, have the computer do it for you! 4.2 Example To illustrate these calculations, we use data on the frog Rana aurora from Table 1 of Biek et al. (2002). There are seven stages (eggs, embryos, larae, metamorphs, juveniles and adults), but the first four are completed in the course of the animal’s first year, so for the model we focus only on eggs, juveniles, and adults. bx &lt;- c(0, 303) px &lt;- c(0.92 * 0.03 * 0.55, 0.36, 0.69) gx &lt;- c(1, 0.09/0.36, 0) l &lt;- 2 B &lt;- rbind(bx, diag(l)) P &lt;- diag(px) T &lt;- diag(1-gx) T[2,1] &lt;- gx[1] T[3,2] &lt;- gx[2] T &lt;- T[-1, ] Apre &lt;- T %*% P %*% B Apost &lt;- B %*% T %*% P References "],
["size-structured-models.html", "Chapter 5 Size-Structured Models", " Chapter 5 Size-Structured Models "],
["sensititivity-analysis.html", "Chapter 6 Sensititivity analysis 6.1 Sensitivity analysis of age-structured MPMs", " Chapter 6 Sensititivity analysis This book is about MPM construction, not the analysis of such models. Nevertheless, the construction of the annual projection matrix by way of separate birth and survival matrices creates a way to easily calculate the sensitivity and elasticity of the asymptotic growth rate (usually denoted \\(\\lambda\\)) to changes in the age-specific birth and death rates. Existing tools (e.g., the sensitivity() function in the popbio R package) can calculate sensitivities of \\(\\lambda\\) to changes in the elements of an annual projection matrix (\\(\\mathbf{A_{post}}\\) or \\(\\mathbf{A_{pre}}\\)). However, the matrix entries may be functions of multiple vital rates, and individual vital rates may appear in multiple matrix entries (see eqs. (3.2)). Extracting the sensitivities of \\(\\lambda\\) to vital rates from the sensitivities of \\(\\lambda\\) to matrix elements requires careful accounting, as well as the application of basic differential calculus; doing this by hand is tedious and error prone. Instead, we can make use of established procedures for sensitivy analysis of “periodic matrix products” (Caswell and Trevisan 1994). We will start with the age-structured model, for which the analysis is particularly straightforward, and then move on to the more complex models. 6.1 Sensitivity analysis of age-structured MPMs Here, there are just two “seasons:” from the beginning of the breeding period to the end of the breeding period (represented by the matrix \\(\\mathbf{B}\\)); and from the end of the breeding period in one year to the beginning of the breeding period in the next year (represented by the matrix \\(\\mathbf{P}\\)). The recipe is as follows: Construct both the postbreeding census and prebreeding census projection matrices (\\(\\mathbf{A_{post}}\\) and \\(\\mathbf{A_{pre}}\\)). Use a standard toolkit to constuct the sensitivity matrices of the two projection matrices. We will call those \\(\\mathbf{S_A}^{\\text{(post)}}\\) and \\(\\mathbf{S_A}^{\\text{(pre)}}\\). Construct the transpose of the \\(\\mathbf{B}\\) and \\(\\mathbf{P}\\) matrices by swapping the rows and columns. We will call these \\(\\mathbf{B^T}\\) and \\(\\mathbf{P^T}\\). For the \\(m=3\\) example, these look like \\[\\begin{equation} \\mathbf{B^T} = \\begin{pmatrix} b_{(\\text{1})} &amp; 1 &amp; 0 &amp; 0\\\\ b_{(\\text{2})} &amp; 0 &amp; 1 &amp; 0\\\\ b_{(\\text{3})} &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} \\end{equation}\\] and \\[\\begin{equation} \\mathbf{P^T} = \\begin{pmatrix} p_{(\\text{0})} &amp; 0 &amp; 0\\\\ 0 &amp; p_{(\\text{1})} &amp; 0\\\\ 0 &amp; 0 &amp; p_{(\\text{1})}\\\\ 0 &amp; 0 &amp; 0 \\end{pmatrix}. \\end{equation}\\] Matrix multiply \\(\\mathbf{P^T}\\) by \\(\\mathbf{S_A}^{\\text{(pre)}}\\). The top row in the resulting matrix contains the sensitivities of \\(\\lambda\\) to the age-specific birth rates. Matrix multiply \\(\\mathbf{B^T}\\) by \\(\\mathbf{S_A}^{\\text{(post)}}\\). The diagonal entries in the resulting matrix contains the sensitivities of \\(\\lambda\\) to the age-specific survival rates. 6.1.1 Example We will revisit the lizard MPM from chapter X. First we will clear the workspace of existing matrices and other relevant objects, and then attach the model we saved in chapter X, which will make opjects like Apre available to us: rm(list = names(lizard_age_mpm)) # Clear the workspace of potential name conflicts attach(lizard_age_mpm) # Get the age structured lizard model from ch. 3. Now use the popbio library to calculate the matrix sensitivities of Apost and Apre: library(popbio) # This library includes tools for calculating lambda and matrix sensitivities # Calculate the sensitivity matrices Spost &lt;- sensitivity(Apost) Spre &lt;- sensitivity(Apre) Now we combine steps 3 and 4 to calculate the sensitivities of \\(\\lambda\\) to survival. To do a matrix transpose in R, use the t() function. # Do the matrix multiplication to calculate the sensitivities to survival Stemp1 &lt;- t(B) %*% Spost diag(Stemp1[, 1:m]) ## [1] 0.837520960 0.480823977 0.366397726 0.198614806 0.125950860 0.014929771 ## [7] 0.008135051 And now we do the same to calculate the sensitivity of \\(\\lambda\\) to age-specific birth rates: # Do the matrix multiplication to calculate the sensitivities to birth rates Stemp2 &lt;- t(P) %*% Spre Stemp2[1, ] ## age 1 age 2 age 3 age 4 age 5 ## 0.1507669993 0.1096028394 0.0563012534 0.0203518625 0.0035663265 ## age 6 age 7 ## 0.0024997584 0.0007158845 [Discuss; show how to get elasticities from these] Finally, it’s always good practice to clean up the workspace! detach(lizard_age_mpm) # Clean up References "],
["references.html", "References", " References "]
]
